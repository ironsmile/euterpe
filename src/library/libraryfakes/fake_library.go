// Code generated by counterfeiter. DO NOT EDIT.
package libraryfakes

import (
	"context"
	"sync"
	"time"

	"github.com/ironsmile/euterpe/src/library"
)

type FakeLibrary struct {
	AddLibraryPathStub        func(string)
	addLibraryPathMutex       sync.RWMutex
	addLibraryPathArgsForCall []struct {
		arg1 string
	}
	AddMediaStub        func(string) error
	addMediaMutex       sync.RWMutex
	addMediaArgsForCall []struct {
		arg1 string
	}
	addMediaReturns struct {
		result1 error
	}
	addMediaReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	GetAlbumStub        func(context.Context, int64) (library.Album, error)
	getAlbumMutex       sync.RWMutex
	getAlbumArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getAlbumReturns struct {
		result1 library.Album
		result2 error
	}
	getAlbumReturnsOnCall map[int]struct {
		result1 library.Album
		result2 error
	}
	GetAlbumFilesStub        func(int64) []library.SearchResult
	getAlbumFilesMutex       sync.RWMutex
	getAlbumFilesArgsForCall []struct {
		arg1 int64
	}
	getAlbumFilesReturns struct {
		result1 []library.SearchResult
	}
	getAlbumFilesReturnsOnCall map[int]struct {
		result1 []library.SearchResult
	}
	GetArtistStub        func(context.Context, int64) (library.Artist, error)
	getArtistMutex       sync.RWMutex
	getArtistArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getArtistReturns struct {
		result1 library.Artist
		result2 error
	}
	getArtistReturnsOnCall map[int]struct {
		result1 library.Artist
		result2 error
	}
	GetArtistAlbumsStub        func(int64) []library.Album
	getArtistAlbumsMutex       sync.RWMutex
	getArtistAlbumsArgsForCall []struct {
		arg1 int64
	}
	getArtistAlbumsReturns struct {
		result1 []library.Album
	}
	getArtistAlbumsReturnsOnCall map[int]struct {
		result1 []library.Album
	}
	GetFilePathStub        func(int64) string
	getFilePathMutex       sync.RWMutex
	getFilePathArgsForCall []struct {
		arg1 int64
	}
	getFilePathReturns struct {
		result1 string
	}
	getFilePathReturnsOnCall map[int]struct {
		result1 string
	}
	GetTrackStub        func(context.Context, int64) (library.SearchResult, error)
	getTrackMutex       sync.RWMutex
	getTrackArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getTrackReturns struct {
		result1 library.SearchResult
		result2 error
	}
	getTrackReturnsOnCall map[int]struct {
		result1 library.SearchResult
		result2 error
	}
	InitializeStub        func() error
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
	}
	initializeReturns struct {
		result1 error
	}
	initializeReturnsOnCall map[int]struct {
		result1 error
	}
	RecordFavouriteStub        func(context.Context, library.Favourites) error
	recordFavouriteMutex       sync.RWMutex
	recordFavouriteArgsForCall []struct {
		arg1 context.Context
		arg2 library.Favourites
	}
	recordFavouriteReturns struct {
		result1 error
	}
	recordFavouriteReturnsOnCall map[int]struct {
		result1 error
	}
	RecordTrackPlayStub        func(context.Context, int64, time.Time) error
	recordTrackPlayMutex       sync.RWMutex
	recordTrackPlayArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 time.Time
	}
	recordTrackPlayReturns struct {
		result1 error
	}
	recordTrackPlayReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveFavouriteStub        func(context.Context, library.Favourites) error
	removeFavouriteMutex       sync.RWMutex
	removeFavouriteArgsForCall []struct {
		arg1 context.Context
		arg2 library.Favourites
	}
	removeFavouriteReturns struct {
		result1 error
	}
	removeFavouriteReturnsOnCall map[int]struct {
		result1 error
	}
	ScanStub        func()
	scanMutex       sync.RWMutex
	scanArgsForCall []struct {
	}
	SearchStub        func(library.SearchArgs) []library.SearchResult
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 library.SearchArgs
	}
	searchReturns struct {
		result1 []library.SearchResult
	}
	searchReturnsOnCall map[int]struct {
		result1 []library.SearchResult
	}
	SearchAlbumsStub        func(library.SearchArgs) []library.Album
	searchAlbumsMutex       sync.RWMutex
	searchAlbumsArgsForCall []struct {
		arg1 library.SearchArgs
	}
	searchAlbumsReturns struct {
		result1 []library.Album
	}
	searchAlbumsReturnsOnCall map[int]struct {
		result1 []library.Album
	}
	SearchArtistsStub        func(library.SearchArgs) []library.Artist
	searchArtistsMutex       sync.RWMutex
	searchArtistsArgsForCall []struct {
		arg1 library.SearchArgs
	}
	searchArtistsReturns struct {
		result1 []library.Artist
	}
	searchArtistsReturnsOnCall map[int]struct {
		result1 []library.Artist
	}
	SetAlbumRatingStub        func(context.Context, int64, uint8) error
	setAlbumRatingMutex       sync.RWMutex
	setAlbumRatingArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 uint8
	}
	setAlbumRatingReturns struct {
		result1 error
	}
	setAlbumRatingReturnsOnCall map[int]struct {
		result1 error
	}
	SetArtistRatingStub        func(context.Context, int64, uint8) error
	setArtistRatingMutex       sync.RWMutex
	setArtistRatingArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 uint8
	}
	setArtistRatingReturns struct {
		result1 error
	}
	setArtistRatingReturnsOnCall map[int]struct {
		result1 error
	}
	SetTrackRatingStub        func(context.Context, int64, uint8) error
	setTrackRatingMutex       sync.RWMutex
	setTrackRatingArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 uint8
	}
	setTrackRatingReturns struct {
		result1 error
	}
	setTrackRatingReturnsOnCall map[int]struct {
		result1 error
	}
	TruncateStub        func() error
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
	}
	truncateReturns struct {
		result1 error
	}
	truncateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLibrary) AddLibraryPath(arg1 string) {
	fake.addLibraryPathMutex.Lock()
	fake.addLibraryPathArgsForCall = append(fake.addLibraryPathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AddLibraryPathStub
	fake.recordInvocation("AddLibraryPath", []interface{}{arg1})
	fake.addLibraryPathMutex.Unlock()
	if stub != nil {
		fake.AddLibraryPathStub(arg1)
	}
}

func (fake *FakeLibrary) AddLibraryPathCallCount() int {
	fake.addLibraryPathMutex.RLock()
	defer fake.addLibraryPathMutex.RUnlock()
	return len(fake.addLibraryPathArgsForCall)
}

func (fake *FakeLibrary) AddLibraryPathCalls(stub func(string)) {
	fake.addLibraryPathMutex.Lock()
	defer fake.addLibraryPathMutex.Unlock()
	fake.AddLibraryPathStub = stub
}

func (fake *FakeLibrary) AddLibraryPathArgsForCall(i int) string {
	fake.addLibraryPathMutex.RLock()
	defer fake.addLibraryPathMutex.RUnlock()
	argsForCall := fake.addLibraryPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) AddMedia(arg1 string) error {
	fake.addMediaMutex.Lock()
	ret, specificReturn := fake.addMediaReturnsOnCall[len(fake.addMediaArgsForCall)]
	fake.addMediaArgsForCall = append(fake.addMediaArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AddMediaStub
	fakeReturns := fake.addMediaReturns
	fake.recordInvocation("AddMedia", []interface{}{arg1})
	fake.addMediaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) AddMediaCallCount() int {
	fake.addMediaMutex.RLock()
	defer fake.addMediaMutex.RUnlock()
	return len(fake.addMediaArgsForCall)
}

func (fake *FakeLibrary) AddMediaCalls(stub func(string) error) {
	fake.addMediaMutex.Lock()
	defer fake.addMediaMutex.Unlock()
	fake.AddMediaStub = stub
}

func (fake *FakeLibrary) AddMediaArgsForCall(i int) string {
	fake.addMediaMutex.RLock()
	defer fake.addMediaMutex.RUnlock()
	argsForCall := fake.addMediaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) AddMediaReturns(result1 error) {
	fake.addMediaMutex.Lock()
	defer fake.addMediaMutex.Unlock()
	fake.AddMediaStub = nil
	fake.addMediaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) AddMediaReturnsOnCall(i int, result1 error) {
	fake.addMediaMutex.Lock()
	defer fake.addMediaMutex.Unlock()
	fake.AddMediaStub = nil
	if fake.addMediaReturnsOnCall == nil {
		fake.addMediaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addMediaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeLibrary) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeLibrary) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeLibrary) GetAlbum(arg1 context.Context, arg2 int64) (library.Album, error) {
	fake.getAlbumMutex.Lock()
	ret, specificReturn := fake.getAlbumReturnsOnCall[len(fake.getAlbumArgsForCall)]
	fake.getAlbumArgsForCall = append(fake.getAlbumArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetAlbumStub
	fakeReturns := fake.getAlbumReturns
	fake.recordInvocation("GetAlbum", []interface{}{arg1, arg2})
	fake.getAlbumMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLibrary) GetAlbumCallCount() int {
	fake.getAlbumMutex.RLock()
	defer fake.getAlbumMutex.RUnlock()
	return len(fake.getAlbumArgsForCall)
}

func (fake *FakeLibrary) GetAlbumCalls(stub func(context.Context, int64) (library.Album, error)) {
	fake.getAlbumMutex.Lock()
	defer fake.getAlbumMutex.Unlock()
	fake.GetAlbumStub = stub
}

func (fake *FakeLibrary) GetAlbumArgsForCall(i int) (context.Context, int64) {
	fake.getAlbumMutex.RLock()
	defer fake.getAlbumMutex.RUnlock()
	argsForCall := fake.getAlbumArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLibrary) GetAlbumReturns(result1 library.Album, result2 error) {
	fake.getAlbumMutex.Lock()
	defer fake.getAlbumMutex.Unlock()
	fake.GetAlbumStub = nil
	fake.getAlbumReturns = struct {
		result1 library.Album
		result2 error
	}{result1, result2}
}

func (fake *FakeLibrary) GetAlbumReturnsOnCall(i int, result1 library.Album, result2 error) {
	fake.getAlbumMutex.Lock()
	defer fake.getAlbumMutex.Unlock()
	fake.GetAlbumStub = nil
	if fake.getAlbumReturnsOnCall == nil {
		fake.getAlbumReturnsOnCall = make(map[int]struct {
			result1 library.Album
			result2 error
		})
	}
	fake.getAlbumReturnsOnCall[i] = struct {
		result1 library.Album
		result2 error
	}{result1, result2}
}

func (fake *FakeLibrary) GetAlbumFiles(arg1 int64) []library.SearchResult {
	fake.getAlbumFilesMutex.Lock()
	ret, specificReturn := fake.getAlbumFilesReturnsOnCall[len(fake.getAlbumFilesArgsForCall)]
	fake.getAlbumFilesArgsForCall = append(fake.getAlbumFilesArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.GetAlbumFilesStub
	fakeReturns := fake.getAlbumFilesReturns
	fake.recordInvocation("GetAlbumFiles", []interface{}{arg1})
	fake.getAlbumFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) GetAlbumFilesCallCount() int {
	fake.getAlbumFilesMutex.RLock()
	defer fake.getAlbumFilesMutex.RUnlock()
	return len(fake.getAlbumFilesArgsForCall)
}

func (fake *FakeLibrary) GetAlbumFilesCalls(stub func(int64) []library.SearchResult) {
	fake.getAlbumFilesMutex.Lock()
	defer fake.getAlbumFilesMutex.Unlock()
	fake.GetAlbumFilesStub = stub
}

func (fake *FakeLibrary) GetAlbumFilesArgsForCall(i int) int64 {
	fake.getAlbumFilesMutex.RLock()
	defer fake.getAlbumFilesMutex.RUnlock()
	argsForCall := fake.getAlbumFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) GetAlbumFilesReturns(result1 []library.SearchResult) {
	fake.getAlbumFilesMutex.Lock()
	defer fake.getAlbumFilesMutex.Unlock()
	fake.GetAlbumFilesStub = nil
	fake.getAlbumFilesReturns = struct {
		result1 []library.SearchResult
	}{result1}
}

func (fake *FakeLibrary) GetAlbumFilesReturnsOnCall(i int, result1 []library.SearchResult) {
	fake.getAlbumFilesMutex.Lock()
	defer fake.getAlbumFilesMutex.Unlock()
	fake.GetAlbumFilesStub = nil
	if fake.getAlbumFilesReturnsOnCall == nil {
		fake.getAlbumFilesReturnsOnCall = make(map[int]struct {
			result1 []library.SearchResult
		})
	}
	fake.getAlbumFilesReturnsOnCall[i] = struct {
		result1 []library.SearchResult
	}{result1}
}

func (fake *FakeLibrary) GetArtist(arg1 context.Context, arg2 int64) (library.Artist, error) {
	fake.getArtistMutex.Lock()
	ret, specificReturn := fake.getArtistReturnsOnCall[len(fake.getArtistArgsForCall)]
	fake.getArtistArgsForCall = append(fake.getArtistArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetArtistStub
	fakeReturns := fake.getArtistReturns
	fake.recordInvocation("GetArtist", []interface{}{arg1, arg2})
	fake.getArtistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLibrary) GetArtistCallCount() int {
	fake.getArtistMutex.RLock()
	defer fake.getArtistMutex.RUnlock()
	return len(fake.getArtistArgsForCall)
}

func (fake *FakeLibrary) GetArtistCalls(stub func(context.Context, int64) (library.Artist, error)) {
	fake.getArtistMutex.Lock()
	defer fake.getArtistMutex.Unlock()
	fake.GetArtistStub = stub
}

func (fake *FakeLibrary) GetArtistArgsForCall(i int) (context.Context, int64) {
	fake.getArtistMutex.RLock()
	defer fake.getArtistMutex.RUnlock()
	argsForCall := fake.getArtistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLibrary) GetArtistReturns(result1 library.Artist, result2 error) {
	fake.getArtistMutex.Lock()
	defer fake.getArtistMutex.Unlock()
	fake.GetArtistStub = nil
	fake.getArtistReturns = struct {
		result1 library.Artist
		result2 error
	}{result1, result2}
}

func (fake *FakeLibrary) GetArtistReturnsOnCall(i int, result1 library.Artist, result2 error) {
	fake.getArtistMutex.Lock()
	defer fake.getArtistMutex.Unlock()
	fake.GetArtistStub = nil
	if fake.getArtistReturnsOnCall == nil {
		fake.getArtistReturnsOnCall = make(map[int]struct {
			result1 library.Artist
			result2 error
		})
	}
	fake.getArtistReturnsOnCall[i] = struct {
		result1 library.Artist
		result2 error
	}{result1, result2}
}

func (fake *FakeLibrary) GetArtistAlbums(arg1 int64) []library.Album {
	fake.getArtistAlbumsMutex.Lock()
	ret, specificReturn := fake.getArtistAlbumsReturnsOnCall[len(fake.getArtistAlbumsArgsForCall)]
	fake.getArtistAlbumsArgsForCall = append(fake.getArtistAlbumsArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.GetArtistAlbumsStub
	fakeReturns := fake.getArtistAlbumsReturns
	fake.recordInvocation("GetArtistAlbums", []interface{}{arg1})
	fake.getArtistAlbumsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) GetArtistAlbumsCallCount() int {
	fake.getArtistAlbumsMutex.RLock()
	defer fake.getArtistAlbumsMutex.RUnlock()
	return len(fake.getArtistAlbumsArgsForCall)
}

func (fake *FakeLibrary) GetArtistAlbumsCalls(stub func(int64) []library.Album) {
	fake.getArtistAlbumsMutex.Lock()
	defer fake.getArtistAlbumsMutex.Unlock()
	fake.GetArtistAlbumsStub = stub
}

func (fake *FakeLibrary) GetArtistAlbumsArgsForCall(i int) int64 {
	fake.getArtistAlbumsMutex.RLock()
	defer fake.getArtistAlbumsMutex.RUnlock()
	argsForCall := fake.getArtistAlbumsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) GetArtistAlbumsReturns(result1 []library.Album) {
	fake.getArtistAlbumsMutex.Lock()
	defer fake.getArtistAlbumsMutex.Unlock()
	fake.GetArtistAlbumsStub = nil
	fake.getArtistAlbumsReturns = struct {
		result1 []library.Album
	}{result1}
}

func (fake *FakeLibrary) GetArtistAlbumsReturnsOnCall(i int, result1 []library.Album) {
	fake.getArtistAlbumsMutex.Lock()
	defer fake.getArtistAlbumsMutex.Unlock()
	fake.GetArtistAlbumsStub = nil
	if fake.getArtistAlbumsReturnsOnCall == nil {
		fake.getArtistAlbumsReturnsOnCall = make(map[int]struct {
			result1 []library.Album
		})
	}
	fake.getArtistAlbumsReturnsOnCall[i] = struct {
		result1 []library.Album
	}{result1}
}

func (fake *FakeLibrary) GetFilePath(arg1 int64) string {
	fake.getFilePathMutex.Lock()
	ret, specificReturn := fake.getFilePathReturnsOnCall[len(fake.getFilePathArgsForCall)]
	fake.getFilePathArgsForCall = append(fake.getFilePathArgsForCall, struct {
		arg1 int64
	}{arg1})
	stub := fake.GetFilePathStub
	fakeReturns := fake.getFilePathReturns
	fake.recordInvocation("GetFilePath", []interface{}{arg1})
	fake.getFilePathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) GetFilePathCallCount() int {
	fake.getFilePathMutex.RLock()
	defer fake.getFilePathMutex.RUnlock()
	return len(fake.getFilePathArgsForCall)
}

func (fake *FakeLibrary) GetFilePathCalls(stub func(int64) string) {
	fake.getFilePathMutex.Lock()
	defer fake.getFilePathMutex.Unlock()
	fake.GetFilePathStub = stub
}

func (fake *FakeLibrary) GetFilePathArgsForCall(i int) int64 {
	fake.getFilePathMutex.RLock()
	defer fake.getFilePathMutex.RUnlock()
	argsForCall := fake.getFilePathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) GetFilePathReturns(result1 string) {
	fake.getFilePathMutex.Lock()
	defer fake.getFilePathMutex.Unlock()
	fake.GetFilePathStub = nil
	fake.getFilePathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeLibrary) GetFilePathReturnsOnCall(i int, result1 string) {
	fake.getFilePathMutex.Lock()
	defer fake.getFilePathMutex.Unlock()
	fake.GetFilePathStub = nil
	if fake.getFilePathReturnsOnCall == nil {
		fake.getFilePathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getFilePathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeLibrary) GetTrack(arg1 context.Context, arg2 int64) (library.SearchResult, error) {
	fake.getTrackMutex.Lock()
	ret, specificReturn := fake.getTrackReturnsOnCall[len(fake.getTrackArgsForCall)]
	fake.getTrackArgsForCall = append(fake.getTrackArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetTrackStub
	fakeReturns := fake.getTrackReturns
	fake.recordInvocation("GetTrack", []interface{}{arg1, arg2})
	fake.getTrackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLibrary) GetTrackCallCount() int {
	fake.getTrackMutex.RLock()
	defer fake.getTrackMutex.RUnlock()
	return len(fake.getTrackArgsForCall)
}

func (fake *FakeLibrary) GetTrackCalls(stub func(context.Context, int64) (library.SearchResult, error)) {
	fake.getTrackMutex.Lock()
	defer fake.getTrackMutex.Unlock()
	fake.GetTrackStub = stub
}

func (fake *FakeLibrary) GetTrackArgsForCall(i int) (context.Context, int64) {
	fake.getTrackMutex.RLock()
	defer fake.getTrackMutex.RUnlock()
	argsForCall := fake.getTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLibrary) GetTrackReturns(result1 library.SearchResult, result2 error) {
	fake.getTrackMutex.Lock()
	defer fake.getTrackMutex.Unlock()
	fake.GetTrackStub = nil
	fake.getTrackReturns = struct {
		result1 library.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *FakeLibrary) GetTrackReturnsOnCall(i int, result1 library.SearchResult, result2 error) {
	fake.getTrackMutex.Lock()
	defer fake.getTrackMutex.Unlock()
	fake.GetTrackStub = nil
	if fake.getTrackReturnsOnCall == nil {
		fake.getTrackReturnsOnCall = make(map[int]struct {
			result1 library.SearchResult
			result2 error
		})
	}
	fake.getTrackReturnsOnCall[i] = struct {
		result1 library.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *FakeLibrary) Initialize() error {
	fake.initializeMutex.Lock()
	ret, specificReturn := fake.initializeReturnsOnCall[len(fake.initializeArgsForCall)]
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct {
	}{})
	stub := fake.InitializeStub
	fakeReturns := fake.initializeReturns
	fake.recordInvocation("Initialize", []interface{}{})
	fake.initializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *FakeLibrary) InitializeCalls(stub func() error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = stub
}

func (fake *FakeLibrary) InitializeReturns(result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	fake.initializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) InitializeReturnsOnCall(i int, result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	if fake.initializeReturnsOnCall == nil {
		fake.initializeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initializeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) RecordFavourite(arg1 context.Context, arg2 library.Favourites) error {
	fake.recordFavouriteMutex.Lock()
	ret, specificReturn := fake.recordFavouriteReturnsOnCall[len(fake.recordFavouriteArgsForCall)]
	fake.recordFavouriteArgsForCall = append(fake.recordFavouriteArgsForCall, struct {
		arg1 context.Context
		arg2 library.Favourites
	}{arg1, arg2})
	stub := fake.RecordFavouriteStub
	fakeReturns := fake.recordFavouriteReturns
	fake.recordInvocation("RecordFavourite", []interface{}{arg1, arg2})
	fake.recordFavouriteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) RecordFavouriteCallCount() int {
	fake.recordFavouriteMutex.RLock()
	defer fake.recordFavouriteMutex.RUnlock()
	return len(fake.recordFavouriteArgsForCall)
}

func (fake *FakeLibrary) RecordFavouriteCalls(stub func(context.Context, library.Favourites) error) {
	fake.recordFavouriteMutex.Lock()
	defer fake.recordFavouriteMutex.Unlock()
	fake.RecordFavouriteStub = stub
}

func (fake *FakeLibrary) RecordFavouriteArgsForCall(i int) (context.Context, library.Favourites) {
	fake.recordFavouriteMutex.RLock()
	defer fake.recordFavouriteMutex.RUnlock()
	argsForCall := fake.recordFavouriteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLibrary) RecordFavouriteReturns(result1 error) {
	fake.recordFavouriteMutex.Lock()
	defer fake.recordFavouriteMutex.Unlock()
	fake.RecordFavouriteStub = nil
	fake.recordFavouriteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) RecordFavouriteReturnsOnCall(i int, result1 error) {
	fake.recordFavouriteMutex.Lock()
	defer fake.recordFavouriteMutex.Unlock()
	fake.RecordFavouriteStub = nil
	if fake.recordFavouriteReturnsOnCall == nil {
		fake.recordFavouriteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.recordFavouriteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) RecordTrackPlay(arg1 context.Context, arg2 int64, arg3 time.Time) error {
	fake.recordTrackPlayMutex.Lock()
	ret, specificReturn := fake.recordTrackPlayReturnsOnCall[len(fake.recordTrackPlayArgsForCall)]
	fake.recordTrackPlayArgsForCall = append(fake.recordTrackPlayArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 time.Time
	}{arg1, arg2, arg3})
	stub := fake.RecordTrackPlayStub
	fakeReturns := fake.recordTrackPlayReturns
	fake.recordInvocation("RecordTrackPlay", []interface{}{arg1, arg2, arg3})
	fake.recordTrackPlayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) RecordTrackPlayCallCount() int {
	fake.recordTrackPlayMutex.RLock()
	defer fake.recordTrackPlayMutex.RUnlock()
	return len(fake.recordTrackPlayArgsForCall)
}

func (fake *FakeLibrary) RecordTrackPlayCalls(stub func(context.Context, int64, time.Time) error) {
	fake.recordTrackPlayMutex.Lock()
	defer fake.recordTrackPlayMutex.Unlock()
	fake.RecordTrackPlayStub = stub
}

func (fake *FakeLibrary) RecordTrackPlayArgsForCall(i int) (context.Context, int64, time.Time) {
	fake.recordTrackPlayMutex.RLock()
	defer fake.recordTrackPlayMutex.RUnlock()
	argsForCall := fake.recordTrackPlayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLibrary) RecordTrackPlayReturns(result1 error) {
	fake.recordTrackPlayMutex.Lock()
	defer fake.recordTrackPlayMutex.Unlock()
	fake.RecordTrackPlayStub = nil
	fake.recordTrackPlayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) RecordTrackPlayReturnsOnCall(i int, result1 error) {
	fake.recordTrackPlayMutex.Lock()
	defer fake.recordTrackPlayMutex.Unlock()
	fake.RecordTrackPlayStub = nil
	if fake.recordTrackPlayReturnsOnCall == nil {
		fake.recordTrackPlayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.recordTrackPlayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) RemoveFavourite(arg1 context.Context, arg2 library.Favourites) error {
	fake.removeFavouriteMutex.Lock()
	ret, specificReturn := fake.removeFavouriteReturnsOnCall[len(fake.removeFavouriteArgsForCall)]
	fake.removeFavouriteArgsForCall = append(fake.removeFavouriteArgsForCall, struct {
		arg1 context.Context
		arg2 library.Favourites
	}{arg1, arg2})
	stub := fake.RemoveFavouriteStub
	fakeReturns := fake.removeFavouriteReturns
	fake.recordInvocation("RemoveFavourite", []interface{}{arg1, arg2})
	fake.removeFavouriteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) RemoveFavouriteCallCount() int {
	fake.removeFavouriteMutex.RLock()
	defer fake.removeFavouriteMutex.RUnlock()
	return len(fake.removeFavouriteArgsForCall)
}

func (fake *FakeLibrary) RemoveFavouriteCalls(stub func(context.Context, library.Favourites) error) {
	fake.removeFavouriteMutex.Lock()
	defer fake.removeFavouriteMutex.Unlock()
	fake.RemoveFavouriteStub = stub
}

func (fake *FakeLibrary) RemoveFavouriteArgsForCall(i int) (context.Context, library.Favourites) {
	fake.removeFavouriteMutex.RLock()
	defer fake.removeFavouriteMutex.RUnlock()
	argsForCall := fake.removeFavouriteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLibrary) RemoveFavouriteReturns(result1 error) {
	fake.removeFavouriteMutex.Lock()
	defer fake.removeFavouriteMutex.Unlock()
	fake.RemoveFavouriteStub = nil
	fake.removeFavouriteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) RemoveFavouriteReturnsOnCall(i int, result1 error) {
	fake.removeFavouriteMutex.Lock()
	defer fake.removeFavouriteMutex.Unlock()
	fake.RemoveFavouriteStub = nil
	if fake.removeFavouriteReturnsOnCall == nil {
		fake.removeFavouriteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeFavouriteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) Scan() {
	fake.scanMutex.Lock()
	fake.scanArgsForCall = append(fake.scanArgsForCall, struct {
	}{})
	stub := fake.ScanStub
	fake.recordInvocation("Scan", []interface{}{})
	fake.scanMutex.Unlock()
	if stub != nil {
		fake.ScanStub()
	}
}

func (fake *FakeLibrary) ScanCallCount() int {
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	return len(fake.scanArgsForCall)
}

func (fake *FakeLibrary) ScanCalls(stub func()) {
	fake.scanMutex.Lock()
	defer fake.scanMutex.Unlock()
	fake.ScanStub = stub
}

func (fake *FakeLibrary) Search(arg1 library.SearchArgs) []library.SearchResult {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 library.SearchArgs
	}{arg1})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *FakeLibrary) SearchCalls(stub func(library.SearchArgs) []library.SearchResult) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *FakeLibrary) SearchArgsForCall(i int) library.SearchArgs {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) SearchReturns(result1 []library.SearchResult) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 []library.SearchResult
	}{result1}
}

func (fake *FakeLibrary) SearchReturnsOnCall(i int, result1 []library.SearchResult) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 []library.SearchResult
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 []library.SearchResult
	}{result1}
}

func (fake *FakeLibrary) SearchAlbums(arg1 library.SearchArgs) []library.Album {
	fake.searchAlbumsMutex.Lock()
	ret, specificReturn := fake.searchAlbumsReturnsOnCall[len(fake.searchAlbumsArgsForCall)]
	fake.searchAlbumsArgsForCall = append(fake.searchAlbumsArgsForCall, struct {
		arg1 library.SearchArgs
	}{arg1})
	stub := fake.SearchAlbumsStub
	fakeReturns := fake.searchAlbumsReturns
	fake.recordInvocation("SearchAlbums", []interface{}{arg1})
	fake.searchAlbumsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) SearchAlbumsCallCount() int {
	fake.searchAlbumsMutex.RLock()
	defer fake.searchAlbumsMutex.RUnlock()
	return len(fake.searchAlbumsArgsForCall)
}

func (fake *FakeLibrary) SearchAlbumsCalls(stub func(library.SearchArgs) []library.Album) {
	fake.searchAlbumsMutex.Lock()
	defer fake.searchAlbumsMutex.Unlock()
	fake.SearchAlbumsStub = stub
}

func (fake *FakeLibrary) SearchAlbumsArgsForCall(i int) library.SearchArgs {
	fake.searchAlbumsMutex.RLock()
	defer fake.searchAlbumsMutex.RUnlock()
	argsForCall := fake.searchAlbumsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) SearchAlbumsReturns(result1 []library.Album) {
	fake.searchAlbumsMutex.Lock()
	defer fake.searchAlbumsMutex.Unlock()
	fake.SearchAlbumsStub = nil
	fake.searchAlbumsReturns = struct {
		result1 []library.Album
	}{result1}
}

func (fake *FakeLibrary) SearchAlbumsReturnsOnCall(i int, result1 []library.Album) {
	fake.searchAlbumsMutex.Lock()
	defer fake.searchAlbumsMutex.Unlock()
	fake.SearchAlbumsStub = nil
	if fake.searchAlbumsReturnsOnCall == nil {
		fake.searchAlbumsReturnsOnCall = make(map[int]struct {
			result1 []library.Album
		})
	}
	fake.searchAlbumsReturnsOnCall[i] = struct {
		result1 []library.Album
	}{result1}
}

func (fake *FakeLibrary) SearchArtists(arg1 library.SearchArgs) []library.Artist {
	fake.searchArtistsMutex.Lock()
	ret, specificReturn := fake.searchArtistsReturnsOnCall[len(fake.searchArtistsArgsForCall)]
	fake.searchArtistsArgsForCall = append(fake.searchArtistsArgsForCall, struct {
		arg1 library.SearchArgs
	}{arg1})
	stub := fake.SearchArtistsStub
	fakeReturns := fake.searchArtistsReturns
	fake.recordInvocation("SearchArtists", []interface{}{arg1})
	fake.searchArtistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) SearchArtistsCallCount() int {
	fake.searchArtistsMutex.RLock()
	defer fake.searchArtistsMutex.RUnlock()
	return len(fake.searchArtistsArgsForCall)
}

func (fake *FakeLibrary) SearchArtistsCalls(stub func(library.SearchArgs) []library.Artist) {
	fake.searchArtistsMutex.Lock()
	defer fake.searchArtistsMutex.Unlock()
	fake.SearchArtistsStub = stub
}

func (fake *FakeLibrary) SearchArtistsArgsForCall(i int) library.SearchArgs {
	fake.searchArtistsMutex.RLock()
	defer fake.searchArtistsMutex.RUnlock()
	argsForCall := fake.searchArtistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLibrary) SearchArtistsReturns(result1 []library.Artist) {
	fake.searchArtistsMutex.Lock()
	defer fake.searchArtistsMutex.Unlock()
	fake.SearchArtistsStub = nil
	fake.searchArtistsReturns = struct {
		result1 []library.Artist
	}{result1}
}

func (fake *FakeLibrary) SearchArtistsReturnsOnCall(i int, result1 []library.Artist) {
	fake.searchArtistsMutex.Lock()
	defer fake.searchArtistsMutex.Unlock()
	fake.SearchArtistsStub = nil
	if fake.searchArtistsReturnsOnCall == nil {
		fake.searchArtistsReturnsOnCall = make(map[int]struct {
			result1 []library.Artist
		})
	}
	fake.searchArtistsReturnsOnCall[i] = struct {
		result1 []library.Artist
	}{result1}
}

func (fake *FakeLibrary) SetAlbumRating(arg1 context.Context, arg2 int64, arg3 uint8) error {
	fake.setAlbumRatingMutex.Lock()
	ret, specificReturn := fake.setAlbumRatingReturnsOnCall[len(fake.setAlbumRatingArgsForCall)]
	fake.setAlbumRatingArgsForCall = append(fake.setAlbumRatingArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 uint8
	}{arg1, arg2, arg3})
	stub := fake.SetAlbumRatingStub
	fakeReturns := fake.setAlbumRatingReturns
	fake.recordInvocation("SetAlbumRating", []interface{}{arg1, arg2, arg3})
	fake.setAlbumRatingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) SetAlbumRatingCallCount() int {
	fake.setAlbumRatingMutex.RLock()
	defer fake.setAlbumRatingMutex.RUnlock()
	return len(fake.setAlbumRatingArgsForCall)
}

func (fake *FakeLibrary) SetAlbumRatingCalls(stub func(context.Context, int64, uint8) error) {
	fake.setAlbumRatingMutex.Lock()
	defer fake.setAlbumRatingMutex.Unlock()
	fake.SetAlbumRatingStub = stub
}

func (fake *FakeLibrary) SetAlbumRatingArgsForCall(i int) (context.Context, int64, uint8) {
	fake.setAlbumRatingMutex.RLock()
	defer fake.setAlbumRatingMutex.RUnlock()
	argsForCall := fake.setAlbumRatingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLibrary) SetAlbumRatingReturns(result1 error) {
	fake.setAlbumRatingMutex.Lock()
	defer fake.setAlbumRatingMutex.Unlock()
	fake.SetAlbumRatingStub = nil
	fake.setAlbumRatingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) SetAlbumRatingReturnsOnCall(i int, result1 error) {
	fake.setAlbumRatingMutex.Lock()
	defer fake.setAlbumRatingMutex.Unlock()
	fake.SetAlbumRatingStub = nil
	if fake.setAlbumRatingReturnsOnCall == nil {
		fake.setAlbumRatingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setAlbumRatingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) SetArtistRating(arg1 context.Context, arg2 int64, arg3 uint8) error {
	fake.setArtistRatingMutex.Lock()
	ret, specificReturn := fake.setArtistRatingReturnsOnCall[len(fake.setArtistRatingArgsForCall)]
	fake.setArtistRatingArgsForCall = append(fake.setArtistRatingArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 uint8
	}{arg1, arg2, arg3})
	stub := fake.SetArtistRatingStub
	fakeReturns := fake.setArtistRatingReturns
	fake.recordInvocation("SetArtistRating", []interface{}{arg1, arg2, arg3})
	fake.setArtistRatingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) SetArtistRatingCallCount() int {
	fake.setArtistRatingMutex.RLock()
	defer fake.setArtistRatingMutex.RUnlock()
	return len(fake.setArtistRatingArgsForCall)
}

func (fake *FakeLibrary) SetArtistRatingCalls(stub func(context.Context, int64, uint8) error) {
	fake.setArtistRatingMutex.Lock()
	defer fake.setArtistRatingMutex.Unlock()
	fake.SetArtistRatingStub = stub
}

func (fake *FakeLibrary) SetArtistRatingArgsForCall(i int) (context.Context, int64, uint8) {
	fake.setArtistRatingMutex.RLock()
	defer fake.setArtistRatingMutex.RUnlock()
	argsForCall := fake.setArtistRatingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLibrary) SetArtistRatingReturns(result1 error) {
	fake.setArtistRatingMutex.Lock()
	defer fake.setArtistRatingMutex.Unlock()
	fake.SetArtistRatingStub = nil
	fake.setArtistRatingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) SetArtistRatingReturnsOnCall(i int, result1 error) {
	fake.setArtistRatingMutex.Lock()
	defer fake.setArtistRatingMutex.Unlock()
	fake.SetArtistRatingStub = nil
	if fake.setArtistRatingReturnsOnCall == nil {
		fake.setArtistRatingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setArtistRatingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) SetTrackRating(arg1 context.Context, arg2 int64, arg3 uint8) error {
	fake.setTrackRatingMutex.Lock()
	ret, specificReturn := fake.setTrackRatingReturnsOnCall[len(fake.setTrackRatingArgsForCall)]
	fake.setTrackRatingArgsForCall = append(fake.setTrackRatingArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 uint8
	}{arg1, arg2, arg3})
	stub := fake.SetTrackRatingStub
	fakeReturns := fake.setTrackRatingReturns
	fake.recordInvocation("SetTrackRating", []interface{}{arg1, arg2, arg3})
	fake.setTrackRatingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) SetTrackRatingCallCount() int {
	fake.setTrackRatingMutex.RLock()
	defer fake.setTrackRatingMutex.RUnlock()
	return len(fake.setTrackRatingArgsForCall)
}

func (fake *FakeLibrary) SetTrackRatingCalls(stub func(context.Context, int64, uint8) error) {
	fake.setTrackRatingMutex.Lock()
	defer fake.setTrackRatingMutex.Unlock()
	fake.SetTrackRatingStub = stub
}

func (fake *FakeLibrary) SetTrackRatingArgsForCall(i int) (context.Context, int64, uint8) {
	fake.setTrackRatingMutex.RLock()
	defer fake.setTrackRatingMutex.RUnlock()
	argsForCall := fake.setTrackRatingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLibrary) SetTrackRatingReturns(result1 error) {
	fake.setTrackRatingMutex.Lock()
	defer fake.setTrackRatingMutex.Unlock()
	fake.SetTrackRatingStub = nil
	fake.setTrackRatingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) SetTrackRatingReturnsOnCall(i int, result1 error) {
	fake.setTrackRatingMutex.Lock()
	defer fake.setTrackRatingMutex.Unlock()
	fake.SetTrackRatingStub = nil
	if fake.setTrackRatingReturnsOnCall == nil {
		fake.setTrackRatingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTrackRatingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) Truncate() error {
	fake.truncateMutex.Lock()
	ret, specificReturn := fake.truncateReturnsOnCall[len(fake.truncateArgsForCall)]
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
	}{})
	stub := fake.TruncateStub
	fakeReturns := fake.truncateReturns
	fake.recordInvocation("Truncate", []interface{}{})
	fake.truncateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLibrary) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeLibrary) TruncateCalls(stub func() error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = stub
}

func (fake *FakeLibrary) TruncateReturns(result1 error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) TruncateReturnsOnCall(i int, result1 error) {
	fake.truncateMutex.Lock()
	defer fake.truncateMutex.Unlock()
	fake.TruncateStub = nil
	if fake.truncateReturnsOnCall == nil {
		fake.truncateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.truncateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLibrary) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addLibraryPathMutex.RLock()
	defer fake.addLibraryPathMutex.RUnlock()
	fake.addMediaMutex.RLock()
	defer fake.addMediaMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.getAlbumMutex.RLock()
	defer fake.getAlbumMutex.RUnlock()
	fake.getAlbumFilesMutex.RLock()
	defer fake.getAlbumFilesMutex.RUnlock()
	fake.getArtistMutex.RLock()
	defer fake.getArtistMutex.RUnlock()
	fake.getArtistAlbumsMutex.RLock()
	defer fake.getArtistAlbumsMutex.RUnlock()
	fake.getFilePathMutex.RLock()
	defer fake.getFilePathMutex.RUnlock()
	fake.getTrackMutex.RLock()
	defer fake.getTrackMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	fake.recordFavouriteMutex.RLock()
	defer fake.recordFavouriteMutex.RUnlock()
	fake.recordTrackPlayMutex.RLock()
	defer fake.recordTrackPlayMutex.RUnlock()
	fake.removeFavouriteMutex.RLock()
	defer fake.removeFavouriteMutex.RUnlock()
	fake.scanMutex.RLock()
	defer fake.scanMutex.RUnlock()
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	fake.searchAlbumsMutex.RLock()
	defer fake.searchAlbumsMutex.RUnlock()
	fake.searchArtistsMutex.RLock()
	defer fake.searchArtistsMutex.RUnlock()
	fake.setAlbumRatingMutex.RLock()
	defer fake.setAlbumRatingMutex.RUnlock()
	fake.setArtistRatingMutex.RLock()
	defer fake.setArtistRatingMutex.RUnlock()
	fake.setTrackRatingMutex.RLock()
	defer fake.setTrackRatingMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLibrary) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ library.Library = new(FakeLibrary)
